/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. .\src\main\java\org\dhbw\ka\ml\generated\Petri.jj */
/*@egen*/options {
                 
    STATIC = false;
}

PARSER_BEGIN(Petri)
package org.dhbw.ka.ml.generated;
public class Petri/*@bgen(jjtree)*/implements PetriTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTPetriState jjtree = new JJTPetriState();

/*@egen*/
    public static void main(String[] args) throws ParseException {
    }
}
PARSER_END(Petri)

SKIP : {
    " "
|   "\r"
|   "\t"
|   "\n"
}

SPECIAL_TOKEN : {
    < ONE_LINE_COMMENT: "#" (~["\n"])* "\n" >
}

TOKEN : {
    < MESSAGE: "message" >
|   < BOOL: "bool" >
|   < INT: "int" >
|   < FLOAT: "float" >
|   < DOUBLE: "double" >
|   < STRING: "string" >
|   < LIST: "List" >
}

TOKEN : {
    < #DIGIT: ["0"-"9"] >
|   < DIGITS: (<DIGIT>)+ >
|   < #LETTER: ["a"-"z","A"-"Z"] >
|   < #ID_ANY: (<DIGIT>|<LETTER>|"_") >
|   < ID: (("_")+ (<DIGIT>|<LETTER>) (<ID_ANY>)* | <DIGITS> (<LETTER>|"_") (<ID_ANY>)* | <LETTER> (<ID_ANY>)*) >
}

ASTroot root():
{/*@bgen(jjtree) root */
  ASTroot jjtn000 = new ASTroot(JJTROOT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) root */
    try {
/*@egen*/
    (complex_type())* <EOF>/*@bgen(jjtree)*/
                            {
                              jjtree.closeNodeScope(jjtn000, true);
                              jjtc000 = false;
                            }
/*@egen*/ { return jjtn000; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void complex_type() :
{/*@bgen(jjtree) complex_type */
  ASTcomplex_type jjtn000 = new ASTcomplex_type(JJTCOMPLEX_TYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) complex_type */
    try {
/*@egen*/
    message()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void message():
{/*@bgen(jjtree) message */
  ASTmessage jjtn000 = new ASTmessage(JJTMESSAGE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) message */
    try {
/*@egen*/
    <MESSAGE> <ID> (":" <ID>)? "{" (field())* "}"/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void field():
{/*@bgen(jjtree) field */
  ASTfield jjtn000 = new ASTfield(JJTFIELD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) field */
    try {
/*@egen*/
    type_identifier() <ID> "=" <DIGITS> ";"/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void type_identifier():
{/*@bgen(jjtree) type_identifier */
  ASTtype_identifier jjtn000 = new ASTtype_identifier(JJTTYPE_IDENTIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) type_identifier */
    try {
/*@egen*/
    primitive_type()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/ // | <ID> | <LIST> "<" type_identifier() ">"
}

void primitive_type():
{/*@bgen(jjtree) primitive_type */
  ASTprimitive_type jjtn000 = new ASTprimitive_type(JJTPRIMITIVE_TYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) primitive_type */
    try {
/*@egen*/
    <BOOL> | <INT> | <FLOAT> | <DOUBLE> | <STRING>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}